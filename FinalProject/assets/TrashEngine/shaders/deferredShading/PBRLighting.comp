#version 460

layout (binding = 0, rgba32f) uniform readonly image2D GBuffer0;
layout (binding = 1, rgba32f) uniform readonly image2D GBuffer1;
layout (binding = 2, rgba32f) uniform readonly image2D GBuffer2;
layout (binding = 3, rgba32f) uniform readonly image2D GBuffer3;
layout (binding = 4, rgba32f) uniform readonly image2D GBuffer4;
layout (location = 0) uniform sampler2D depthImage;

layout (binding = 6) uniform writeonly image2D outputImage;

// binding global uniform buffer for
layout (binding = 0) uniform globalBuffer {
	mat4 projectionMatrix;
	mat4 viewMatrix;
	mat4 inverseProjectionMatrix;
	vec4 cameraPosition;
}GlobalUbo;

struct PointLight {
	vec4 position;		// pos(x, y, z), enable
	vec4 color;
	vec4 attenuation;	// attenuation.w = radius
};

layout (std430, binding = 1) buffer pointLightBuffer {
	uvec4 numberOfPointLights;			// just in x
	PointLight pointLights[];
};

struct DirectionLight {
	vec4 direction;		// dir(x, y, z), enable
	vec4 color;
};

layout (std430, binding = 2) buffer directionLightBuffer {
	uvec4 numberOfDirectionLights;			// just in x
	DirectionLight directionLights[];
};

/*
struct LightGrid {
	uint offset;
	uint count;
};

layout (std430, binding = 3) buffer lightIndexBuffer {
	uint globalLightIndexList[];
};

layout (std430, binding = 4) buffer lightGridBuffer {
	LightGrid lightGrid[];
};

float linearDepth(float depthSample);

float linearDepth(float depthSample){
    float depthRange = 2.0 * depthSample - 1.0;
    //float depthRange = depthSample;
    // Near... Far... wherever you are...
    float linear = 2.0 * zNear * zFar / (zFar + zNear - depthRange * (zFar - zNear));
    return linear;
}


*/
const uint gridSizeX = 16;
const uint gridSizeY = 9;
const uint gridSizeZ = 24;
const float zNear = 0.1f;
const float zFar = 1000f;
const uint sizeX = uint(ceil(1280.0 / float(gridSizeX)));

struct Material {
	vec3 albedo;
	vec3 normal;
	float metallic;
	float roughness;
	float ao;
	float emissive;
};

const float PI = 3.14159265359;

float distributionGGX(float NdotH, float roughness)
{
    float a      = roughness*roughness;
    float a2     = a*a;
    float NdotH2 = NdotH*NdotH;
	
    float num   = a2;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    denom = PI * denom * denom;
	
    return num / max(denom, 0.0000001);
}

float geometrySmith(float NdotV, float NdotL, float roughness)
{
    float r = (roughness + 1.0);
    float k = (r*r) / 8.0;

    float ggx2  = NdotV / (NdotV * (1.0 - k) + k);
    float ggx1  = NdotL / (NdotL * (1.0 - k) + k);
	
    return ggx1 * ggx2;
}

vec3 fresnelSchlick(float HdotV, vec3 baseReflectivity)
{
	return baseReflectivity + (1.0 - baseReflectivity) * pow(1.0 - HdotV, 5.0);
}

/**
	unitViewDir = normalize(camPos - FragPos) in world space
*/
vec3 calcDirectionLight(DirectionLight light, vec3 unitViewDir, vec3 FragPos, Material material) {

	vec3 baseReflectivity = mix(vec3(0.04), material.albedo, material.metallic);
	
	// reflection equation
	
	vec3 N = material.normal;
	vec3 V = unitViewDir;
	
	vec3 L = normalize(-light.direction.xyz);
	vec3 H = normalize(V + L);
	
	vec3 radiance = light.color.xyz;
	
	// Cook-Torrance BRDF
	float NdotV = max(dot(N, V), 0.0000001);
	float NdotL = max(dot(N, L), 0.0000001);
	float HdotV = max(dot(H, V), 0.0);
	float NdotH = max(dot(N, H), 0.0);
	
	float D = distributionGGX(NdotH, material.roughness);
	float G = geometrySmith(NdotV, NdotL, material.roughness);
	vec3 F = fresnelSchlick(HdotV, baseReflectivity);
	
	vec3 specular = D * G * F;
	specular/= 4.0 * NdotV * NdotL;
	
	vec3 kD = vec3(1.0) - F;
	
	kD *= 1.0 - material.metallic;
	
	return (kD * material.albedo / PI + specular) * radiance * NdotL;
}

vec3 calcPointLight(PointLight light, vec3 unitViewDir, vec3 FragPos, Material material) {
	
	vec3 baseReflectivity = mix(vec3(0.04), material.albedo, material.metallic);
	
	// reflection equation
	
	vec3 N = material.normal;
	vec3 V = unitViewDir;
	
	vec3 toLightVector = light.position.xyz - FragPos;
	
	vec3 L = normalize(toLightVector);
	vec3 H = normalize(V + L);
	
	float lightDistance = length(toLightVector);
	float attenuation = 1.0 / max(light.attenuation.x + light.attenuation.y * lightDistance + light.attenuation.z * (lightDistance * lightDistance), 1.0);
	vec3 radiance = light.color.xyz * attenuation;
	
	// Cook-Torrance BRDF
	float NdotV = max(dot(N, V), 0.0000001);
	float NdotL = max(dot(N, L), 0.0000001);
	float HdotV = max(dot(H, V), 0.0);
	float NdotH = max(dot(N, H), 0.0);
	
	float D = distributionGGX(NdotH, material.roughness);
	float G = geometrySmith(NdotV, NdotL, material.roughness);
	vec3 F = fresnelSchlick(HdotV, baseReflectivity);
	
	vec3 specular = D * G * F;
	specular/= 4.0 * NdotV * NdotL;
	
	vec3 kD = vec3(1.0) - F;
	
	kD *= 1.0 - material.metallic;
	
	return (kD * material.albedo / PI + specular) * radiance * NdotL;
	
}

// test
vec3 colors[7] = vec3[](
   vec3( 0,  0,  1), vec3( 0, 1, 0),  vec3(0, 1,  1),
   vec3(1,  0,  0),  vec3( 1,  0,  1), vec3( 1, 1, 0),  vec3(1, 1, 1)
);

// 1 pixel -> 1 thread
layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
void main() {

	vec4 debug_Color = vec4(0.0, 0.0, 0.0, 0.0);

	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	
	// calc what cluster this pixel in
	// scale = (float)gridSizeZ / std::log2f(zFar / zNear) ;
	// bias    = -((float)gridSizeZ * std::log2f(zNear) / std::log2f(zFar / zNear)) ;
	// for fast purpose I use const variable
	vec2 texCoord = vec2(pixel_coords.x / 1280.0, pixel_coords.y / 720.0);
	
	//float currentDepth = texture(depthImage, texCoord).r;
	//float w = -1.0 / GlobalUbo.projectionMatrix[2][3];
	//currentDepth = currentDepth * w;
	
	
	//float scale = float(gridSizeZ) / log2(zFar / zNear);
	//float bias = -(float(gridSizeZ) * log2(zNear) / log2(zFar / zNear));
	//uint zTile = uint(max(log2(linearDepth(currentDepth))/* * scale * bias*/, 0.0));
	////uint zTile = uint(max(log2(currentDepth * (zFar - zNear)), 0.0));
	
	////uint zTile = uint(max(log2(currentDepth) * scale * bias, 0.0));
	//ivec3 clusterVector = ivec3(pixel_coords.xy / sizeX, zTile);
	//uint clusterIndex = clusterVector.x +
	//					gridSizeX * clusterVector.y +
	//					(gridSizeX * gridSizeY) * clusterVector.z;
	// 我懷疑clusterIndex計算有問題

	
	vec4 GBufferTexture0 = imageLoad(GBuffer0, pixel_coords);
	vec4 GBufferTexture1 = imageLoad(GBuffer1, pixel_coords);
	vec4 GBufferTexture2 = imageLoad(GBuffer2, pixel_coords);
	vec4 GBufferTexture3 = imageLoad(GBuffer3, pixel_coords);
	vec4 GBufferTexture4 = imageLoad(GBuffer4, pixel_coords);
	
	vec3 fragPosition = GBufferTexture0.rgb;
	vec3 normal = normalize(vec3(GBufferTexture0.w, GBufferTexture1.xy));
	vec3 albedoColor = vec3(GBufferTexture1.zw, GBufferTexture2.x);
	
	vec3 unitViewDir = normalize(GlobalUbo.cameraPosition.xyz - fragPosition);
	
	// current material
	Material material;
	material.albedo = albedoColor;
	material.normal = normal;
	material.metallic = GBufferTexture2.y;
	material.roughness = GBufferTexture2.z;
	material.ao = GBufferTexture2.w;
	material.emissive = GBufferTexture3.x;

	vec4 out_Color = vec4(0.0);
	out_Color.rgb += material.albedo * material.emissive;
	
	if (albedoColor.x > 0 || albedoColor.y > 0 || albedoColor.z > 0) {
		//uint pointLightCount = lightGrid[clusterIndex].count;
		//uint pointLightOffset = lightGrid[clusterIndex].offset;
		
		vec3 totalLightColor = vec3(0.0);
		/*
		for(uint i = 0; i < pointLightCount; i++) {
			uint lightVectorIndex = globalLightIndexList[pointLightOffset + i];
			// point light calculation
			if (pointLightCount != 2) {
				//debug_Color.g = 1.0;
			}
			totalLightColor += calcPointLight(pointLights[lightVectorIndex], fragPosition, normal);
		}
		*/
		
		// 先使用純deferred shading 因為沒時間研究
		for(uint i = 0; i < numberOfPointLights.x; i++) {
			totalLightColor += calcPointLight(pointLights[i], unitViewDir, fragPosition, material);
		}
		
		// direction light (not effect by attenuation)
		for(uint i = 0; i < numberOfDirectionLights.x; i++) {
			totalLightColor += calcDirectionLight(directionLights[i], unitViewDir, fragPosition, material);
		}
		
		//totalLightColor = max(totalLightColor, 0.1);
		
		out_Color += vec4(totalLightColor, 1.0);
		
	}
	//debug_Color.b += 0.1 * pointLightCount;
	//out_Color += debug_Color;

	// test slicing
	//out_Color = vec4(colors[uint(mod(zTile, 7))], 1.0);
	//out_Color = vec4(currentDepth, 0, 0, 1.0);
	
	// OpenGL is not inverse, but vulkan is inverse in y coordinate
	imageStore(outputImage, ivec2(pixel_coords.x, pixel_coords.y), out_Color);
	
	
}
